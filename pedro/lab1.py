# -*- coding: utf-8 -*-
"""PRACTICA-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1__BBTCySXJEKyVpuB0Uf2VZqwLgBuH8A
"""

# PRÁCTICA 1. RAMIFICACIÓN, CONDICIONALES E ITERACIÓN.
# 1. EJERCICIOS BASICOS
# 1.1. EL PRIMER MÚLTIPLO DE UN NÚMERO
def primer_multiplo(n,L):
  for posicion, numero in enumerate(L):
    if numero%n == 0:
      return posicion
  return -1

# 1.2. CONCATENAR CADENAS DE TEXTO.
def concatena_lineas(lista_lineas):
  poema = ''
  for frase in lista_lineas:
    poema += frase + '\n'
  return poema


# 1.3. PROBABILIDAD DE COINCIDENCIA EN LA FECHA DE CUMPLEAÑOS.
def prob_mismo_cumple(n):
 p = 1
 for i in range(1, n+1):
    p = p * (366 - i) / 365
 return 1-p

# 1.4. SUMA DE SERIE.
def suma_serie(n):
  s = 0
  for i in range(1,n+1):
    s = s + 1/(i**2)
  return s

# 1.5. NÚMEROS FEOS.
def primer_feo(lista):
    for j in lista:
            for i in [2,3,5]:
                s = j
                while s%i == 0:
                    s = s/i
            if s == 1:
                return j

# 1.6. SUMA DE DÍGITOS.
def suma_digitos(n):
  
  while n > 9:
    s = 0
    for i in list(str(n)):
      s = s + int(i)
    n = s
  return n


# 1.7. CONJUNTO DE MANDELBROT.
def en_mandelbrot(x,y):
  c = complex(x,y)
  z = 0
  cumple = True
  for i in range(80):
    z = z**2 + c
    if abs(z) > 2:
        cumple =  False
  return cumple


# 1.8. NÚMEROS PERSISTENTES.
def primer_persistente(n):
    for i in range (10,10000):
        persistencia = gradopersistencia(i)
        if (persistencia == n):
            return i

def gradopersistencia(num):
    persistencia = 0
    while (len(str(num))>=2):
        j = 1
        for i in str(num):
            j *= int(i)
        num = j
        persistencia += 1
    return persistencia



# 1.9. CUADRONES FUERTES
import math 
def primer_cuadron_fuerte():
  for i in range(1,100000):
    if cuadron(i):
      a = str(i)
      if a[0] == '1':
        a = '2' + a[1:len(a)]
        if cuadron(int(a)):
          return i
def cuadron(n):
  raiz = math.sqrt(n)
  p_ent = int(raiz)
  p_dec = raiz - p_ent
  if p_dec == 0.0:
    return True
  else:
    return False


# 1.10. NÚMEROS ONDULANTES.
def es_ondulante(n):
  num = str(n)
  for i in range(2,len(num)-1):
     if (num[i-1] <= num[i] and num[i+1] >= num[i])  or (num[i-1] >= num[i] and num[i+1] <= num[i]):
       return False
  return True

##EJERCICIOS DE CONJETURA Y COMPROBACION 
# Ejercicio 2.1. Derivación de polinomios
def polyder(pol):
  derivada = []
  for posicion,coef in enumerate(pol):
    if posicion > 0:
     derivada.append(posicion*coef)
  return derivada


# Ejercicio 2.2. Evaluación de polinomios.
def polyval(p,x):
  valor = 0
  for posicion,coef in enumerate(p):
    valor = valor + coef*(x**posicion)
  return valor

# Ejercicio 2.3. Teorema de Bolzano.
def polyval(p,x):
  valor = 0
  for posicion,coef in enumerate(p):
    valor = valor + coef*(x**posicion)
  return valor
def rng(minimo, maximo):
    from random import random
    return minimo + random()*(maximo - minimo)

def root_bolzano(pol):
  prec = 1e-7
  lista=[]
  a = rng(-1000, 1000)
  b = rng(-1000, 1000)
  fa = polyval(pol,a)
  lista.append(a)
  fb = polyval(pol,b)
  while (fb*fa > 0):
    b = rng(-1000, 1000)
    fb = polyval(pol,b)
  lista.append(b)
  while (abs(lista[0]-lista[1])>=prec):
    medio = (lista[0]+lista[1])/2.0
    if (polyval(pol,medio) * polyval(pol,lista[0]))>0:
      lista[0] = medio
    else:
      lista[1] = medio
  return (lista[0]+lista[1])/2.0

# Ejercicio 2.4. Newton-raphson general.

def rng(minimo, maximo):
    from random import random
    return minimo + random()*(maximo - minimo)
def polyval(p,x):
  valor = 0
  for posicion,coef in enumerate(p):
    valor = valor + coef*(x**posicion)
  return valor
def polyder(pol):
  derivada = []
  for posicion,coef in enumerate(pol):
    if posicion > 0:
     derivada.append(posicion*coef)
  return derivada
  
def root_newton_raphson(pol,epsilon):
  root = 0
  medio = 0
  lista=[]
  a = rng(-1000, 1000)
  b = rng(-1000, 1000)
  fa = polyval(pol,a)
  lista.append(a)
  fb = polyval(pol,b)

  while (fb*fa > 0):
    b = rng(-1000, 1000)
    fb = polyval(pol,b)
    lista.append(b)
    medio = (lista[0] + lista[1])/2
    root = medio -  polyval(pol,medio)/polyval(polyder(pol),medio)
  while (abs(root - medio))>= epsilon:
    medio = root
    root = medio - polyval(pol,medio)/polyval(polyder(pol),medio)
  return root
