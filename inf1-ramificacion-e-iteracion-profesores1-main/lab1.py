# -*- coding: utf-8 -*-
"""Practicas01_sucio.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wMLb9N86ruj4myNmU8kGa1twzgct5aM7
"""

def primer_feo(sec):
  for numero in sec:
    if es_feo(numero) == True:
      return numero
  return None

def es_feo(numero):
  # es feo si los Ãºnicos divisores primos son 2, 3 o 5
  feo = False
  if (numero%2 == 0) or (numero%3 == 0) or (numero%5 == 0):
    feo = True
  for i in range(7,999):
    if es_primo(i):
        if numero%i == 0:
          return False
  return feo

def es_primo(n):
    is_prime = True
    for i in range(2,n):
        if n%i == 0:
            is_prime = False
    return is_prime

def primer_persistente(n):
    for i in range (10,10000):
        grado = gradopersistencia(i)
        if (grado == n):
            return i

def gradopersistencia(num):
    grado = 0
    while (len(str(num))>=2):
        per = 1
        for i in str(num):
            per *= int(i)
        num = per
        grado += 1
    return grado


# 11             ***** BUCLE que va del 10 al 99999***
# 1 * 1 = 1 ***** RECORRO NUMERO
# --> 1  como es menor que 10 ya hemos terminado  **** CONDICION  SI ES MENOR ESE ES EL GRADO****
#                               ****** SI ES MAYOR QUE 10 TIENE QUE SEGUIR DESCOMPONIENDO ******
# grado persistencia 1  ***** CONDICION SI EL GRADO ES == AL QUE ME PIDEN TENEMOS SOLUCION *****
#21
# 2*1 = 2 y es < 10
# grado 1
#25
#2*5 = 10 > 10 --> 1*0 = 0 < 10
#grado 2
#

def es_ondulante2(n):
  num = str(n)
  for i in range(2,len(num)-1):
     if ((num[i-1] <= num[i]) and (num[i+1] >= num[i]))  or ((num[i-1] >= num[i]) and (num[i+1] <= num[i])):
       return False
  return True

def es_ondulante(n):
  num = str(n)
  for pos, valor in enumerate(num):
    if (pos > 1) and (pos < (len(num)-1)):
      if (num[pos-1] <= valor and (num[pos+1] >= valor)) or (num[pos-1] >= valor and (num[pos+1] <= valor)):
        return False
  return True

#Cuadron Perfecto 

import math

def primer_cuadron_fuerte():
  for i in range(1,100000):
    if cuadron(i): 
      c = str(i)
      if c[0] == "1":
        c = "2"+c[1:len(c)]
        if cuadron(int(c)):
          return i


def cuadron(n):
  raiz = math.sqrt(n)
  entera = int(raiz)
  decimales = raiz - entera
  if decimales == 0.0:
    return True
  else:
    return False
    
def polyval(p,x):
  valor = 0
  for posicion,coef in enumerate(p):
    valor = valor + coef*(x**posicion)
  return valor


def rng(minimo, maximo):
    from random import random
    return minimo + random()*(maximo - minimo)
    
def root_bolzano(pol):
  prec = 1e-7
  lista=[]
  a = rng(-1000, 1000)
  b = rng(-1000, 1000)
  fa = polyval(pol,a)
  lista.append(a)
  fb = polyval(pol,b)
  while (fb*fa > 0):
    b = rng(-1000, 1000)
    fb = polyval(pol,b)
  lista.append(b)
  while (abs(lista[0]-lista[1])>=prec):
    medio = (lista[0]+lista[1])/2.0
    if (polyval(pol,medio) * polyval(pol,lista[0]))>0:
      lista[0] = medio
    else:
      lista[1] = medio
  return (lista[0]+lista[1])/2.0